* Functions have a limit on 255 parameters? OMG
* 37 minutes
* `invokespecial`bytecode instruction: invoke instance method

- IN: 09:36
- OUT: 09:59
- 10:17
- IN: 10:00
CREMEPROTG3 -> 17896772300802
CREMEPROTG3/1KG -> 17896772318296
CREMEPROTG3EXTR -> 17896772317251
PRTSLRFPS30 -> 17896772308693
PRTSLRFPS30C/REP -> 17896772308815
PRTSLRFPS60 -> 17896772316612
PRTSLRFPS60C/REP -> 17896772319040
PRTSLRFPS30C/REP1KG -> 17896772319057
* OUT: 10:18
* 41 minutes
* 11h00
* In bytecode, primitives have single letter descriptors, while classes have L descriptors(Ljava/lang/Object;). Prepending `[` we have an array type descriptor. `V` means void
- C's memory model is even simpler. It get compiled down to bare metal, and much information suffers erasure, same ways as Java generics. Scala native suggests that structs suffers erasure (it don't passes after compilation), because the access to CStructs are maded with positional-like fields (struct._1, struct._2).  
- Obviously optimizations are constrained to the targeted runtime or compiler. Just like memory alignments in C or byte count of a function compilation on JVM (to take advantage of inline and threshold)
- In direct analogy, the Java is for bytecode what C is for assembly code (Linus Torvalds once told that we can predict the shape of assembly the C compiler would produce. Same for Java)
- Rust and python make it opaque for us, but Java makes it transparent. Implicitly, `invokespecial` and `invokevirtual` takes the object ref as it's first arg. So `this` is an implicit pointer to the object.
- IN 10h46
- OUT 10h59
- 11h14
- Primitive types implements Serializable and Comparable. Semantically, my own primitives is a same as the boxed primitive types, so, I should leverage comparable in order to able interoperation with generic code.
- Another aspect that is fact of investigation is how the boxed types are really implemented.
- Constructors should preview boxed types, but I'll leverage the two forms, I don't want to allow autoboxing to take it's place.
- Comparing two objects that are not the same impose some level of challenge on design of methods. See, what should I consider here? When they are no the same object or the same semantically object, I should return that are 'semantically' equal? It doesnt seems that it should be correct. Throwing an error might introduce some types of problems, but can be complemented with API docs. It imposes limitations in mixed collections
- Integer and Double extends from Number, which is an abstract class. However, Number don't implements Comparable. It's implemented on subclass.
- Interfaces cannot override a method from `java.lang.Object`
- https://cr.openjdk.org/~jrose/values/values-0.html#example-comparison
- [ ] Fazer o hoisting do commandParam para evitar passar objetos para baixo
- [ ] Testes indo
	- [x] Tentar integrar uma remessa sem cadastrar associações de local de estoque
		- Resultado: não integra com mensagem informativa
	- [x] Integrar uma remessa com local de estoque de entrada
		-  Resultado: sucesso com expedição de transferência
	- [x] sem local de estoque de entrada
		- Resultado: sucesso, cria expedição sem transferência
	- [x] Com algum produto sem local de estoque de entrada
		- Resultado: sucesso, porém ignora o produto sem local de estoque de entrada. É inclusa mensagem informativa em orientações
	- [x] Alterar uma remessa com local de estoque de entrada
		- AVISO: pode ser que no momento da alteração haja remoção de um dos produtos, onde uma das expedições criadas deixem de ser atualizadas. Neste caso, caso haja um chamado no suporte quanto a Remessa de produto que esteja ligada a expedição de transferência que não está sendo concluída, convém analisar se há uma expedição que 'ficou para trás', excluí-la e enviar o webhook novamente 
	- [x] Tentar criar remessa com destinatário que não tem armazém
		- Resultado: não integra com mensagem informativa
	- [x] Tentar integrar uma remessa onde um dos locais de estoque de entrada não esteja associado
		- Resultado: não integra com mensagem informativa
- [ ] Pensar em uma forma de analisar a integridade das expedições com a Remessa
- [ ] Testes voltando